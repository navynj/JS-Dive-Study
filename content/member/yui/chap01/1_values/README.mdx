# Study Note
  - What is a value in JavaScript?
    To be able to work with quantities of bits without getting lost, 
    we separate them into chunks that represent pieces of information. 
    In a JavaScript environment, those chunks are called values. 
    Though all values are made of bits, they play different roles. 
    Every value has a type that determines its role. 
    Some values are numbers, some values are pieces of text, 
    some values are functions, and so on.

  - How do values represent data in your program?
    In programming, "values" represent specific pieces of data, like numbers, 
    text, or boolean states, that a program can manipulate and store within variables.

- The seven primitive types in JavaScript
    string
    number
    boolean
    null
    undefined
    bigint
    symbol

- Characteristics of primitive types with examples (e.g., immutability).
    1. Immutable (Cannot Be Changed)
    Primitive values themselves cannot be modified after they are created.
    If you try to modify a primitive value, it does not change the original value 
    but instead creates a new value.

    Example: Strings are immutable
    --------------------------------------------------------------------
    let str = "hello";
    str[0] = "H";  // Trying to modify a character (doesn't work)
    console.log(str);  // "hello" (unchanged)

    str = "Hello";  // Assigning a new value is possible
    console.log(str);  // "Hello"
    --------------------------------------------------------------------

    Example: Numbers are also immutable
    --------------------------------------------------------------------
    let num = 10;
    num + 5;  // Creates a new value (15), but `num` remains 10
    console.log(num);  // 10 (unchanged)
    --------------------------------------------------------------------

    2. Stored Directly in Memory (Not References)
    Primitive values are stored directly in memory (not as references like objects).
    When you assign a primitive value to another variable, a copy of the value is created, 
    not a reference.

    Example: Copying primitive values creates independent copies
    --------------------------------------------------------------------
    let a = 5;
    let b = a;  // Copying the value, not a reference
    b = 10;  // Changing `b` does not affect `a`

    console.log(a);  // 5 (unchanged)
    console.log(b);  // 10 (independent copy)
    --------------------------------------------------------------------

    3. Compared by Value (Not by Reference)
    Since primitive types are stored directly in memory, 
    they are compared by their actual values, not references.

    Example: Two strings with the same value are considered equal
    --------------------------------------------------------------------
    let str1 = "hello";
    let str2 = "hello";

    console.log(str1 === str2);  // true (same value)
    --------------------------------------------------------------------

    - What are reference types, and how do they differ from primitives?
    Reference types are objects in JavaScript. Unlike primitives, 
    they are stored by reference in memory, 
    meaning variables don’t hold the actual value but instead hold a reference (or pointer) 
    to the location in memory where the value is stored.

    Examples of Reference Types:
        Objects ({})
        Arrays ([])
        Functions (function() {})
        Dates (new Date())
        Regular Expressions (/pattern/)
        Maps & Sets (new Map(), new Set())

    Reference Types are stored in the Heap (copied by reference)
    --------------------------------------------------------------------
    let obj1 = { name: "Alice" };
    let obj2 = obj1; // obj2 gets a REFERENCE to obj1's memory location

    obj2.name = "Bob"; // Changing obj2 also affects obj1

    console.log(obj1.name); // "Bob" (changed!)
    console.log(obj2.name); // "Bob" (same reference)
    --------------------------------------------------------------------
    ===>Both obj1 and obj2 point to the same object in memory. Changing obj2 also modifies obj1.

    Objects are compared by reference
    --------------------------------------------------------------------
    let objA = { key: "value" };
    let objB = { key: "value" };

    console.log(objA === objB); // false (different memory locations)

    let objC = objA; // Assigning a reference
    console.log(objA === objC); // true (same reference)

    let objA = { key: "value" };
    let objB = { key: "value" };

    console.log(objA === objB); // false (different memory locations)

    let objC = objA; // Assigning a reference
    console.log(objA === objC); // true (same reference)
    --------------------------------------------------------------------
    ===>Even though objA and objB have identical contents, 
        they are stored in different memory locations, so === returns false.

    Copying Reference Types: Shallow vs. Deep Copy

    Shallow Copy (References the Same Object)
    --------------------------------------------------------------------
    let original = { name: "Alice" };
    let shallowCopy = original; // Both point to the same object

    shallowCopy.name = "Bob"; // Modifies the original object too
    console.log(original.name); // "Bob" (unexpected change!)
    --------------------------------------------------------------------
    ===>Shallow copies just copy the reference, so modifying one affects the other.

    Deep Copy (Creates a New Independent Object)
    --------------------------------------------------------------------
    let original = { name: "Alice" };
    let deepCopy = structuredClone(original);

    deepCopy.name = "Bob"; // Does not affect original
    console.log(original.name); // "Alice" (unchanged)
    console.log(deepCopy.name); // "Bob"
    --------------------------------------------------------------------
    ===> Now deepCopy is independent of original, and modifying it doesn’t affect the original object.

- Operators (+, -, *, /, %)

- Logical Operators (&&, ||, !)

- The difference between '==' and '==='
    == (Loose Equality) → Compares values only, allowing type coercion.
    === (Strict Equality) → Compares both value and type, no type conversion.

- The difference between implicit and explicit type coercion.
    Implicit Type Coercion (Automatic Conversion)
        JavaScript automatically converts types when needed.
        Happens in operations like +, -, ==.
        JavaScript does it automatically (can cause bugs).
        --------------------------------------------------------------------
        console.log("5" - 2);  // 3  (String → Number)
        console.log(10 == "10"); // true (String → Number)
        --------------------------------------------------------------------

    Explicit Type Coercion (Manual Conversion)
        You manually convert types using functions like Number(), String(), Boolean().
        You control the conversion (safer and recommended). 
        --------------------------------------------------------------------
        console.log(Number("123"));  // 123 (String → Number)
        console.log(String(456));    // "456" (Number → String)
        console.log(Boolean(0));     // false (0 → Boolean)
        --------------------------------------------------------------------

- How type coercion works in operations like addition, subtraction, and comparison.
    Addition (+)
    When a number is added to a string, JavaScript converts the number to a string (string concatenation).
    --------------------------------------------------------------------
    console.log("5" + 2);   // "52"  (2 is converted to "2" and concatenated)
    console.log(5 + "5");   // "55"  (5 is converted to "5" and concatenated)
    --------------------------------------------------------------------

    Subtraction (-)
    When subtracting a string from a number, JavaScript converts the string to a number (if possible).
    --------------------------------------------------------------------
    console.log("5" - 2);   // 3    ("5" is converted to 5, then subtracted)
    console.log("5" - "2"); // 3    ("5" and "2" are converted to numbers, then subtracted)
    console.log("5" - "a"); // NaN  ("a" cannot be converted to a number)
    --------------------------------------------------------------------

    Comparison (==)
    JavaScript coerces types to make the values comparable.
    --------------------------------------------------------------------
    console.log(5 == "5");   // true  (String "5" is converted to number)
    console.log(0 == false); // true  (0 is converted to false)
    console.log(null == undefined); // true (they are considered equal in loose comparison)
    --------------------------------------------------------------------


# Exercises

| No. | Exercise                                                                                                                        | PR  |
| --- | ------------------------------------------------------------------------------------------------------------------------------- | --- |
| 01  | [Type Coercion Calculator](https://github.com/navynj/JS-Dive-Study/blob/main/content/guideline/chap01/1_values/exercise01.mdx)   | #   |
| 02  | [Game Save Point Management](https://github.com/navynj/JS-Dive-Study/blob/main/content/guideline/chap01/1_values/exercise02.mdx) | #   |
